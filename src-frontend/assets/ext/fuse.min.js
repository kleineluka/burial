!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Fuse = t() }(this, function () { "use strict"; function e(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), n.push.apply(n, i) } return n } function t(t) { for (var n = 1; n < arguments.length; n++) { var i = null != arguments[n] ? arguments[n] : {}; n % 2 ? e(Object(i), !0).forEach(function (e) { c(t, e, i[e]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : e(Object(i)).forEach(function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e)) }) } return t } function n(e) { return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function i(e, t) { if (!(e instanceof t)) throw TypeError("Cannot call a class as a function") } function r(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, d(i.key), i) } } function o(e, t, n) { return t && r(e.prototype, t), n && r(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e } function c(e, t, n) { return (t = d(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function a(e, t) { if ("function" != typeof t && null !== t) throw TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && u(e, t) } function s(e) { return (s = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function e(t) { return t.__proto__ || Object.getPrototypeOf(t) })(e) } function u(e, t) { return (u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function e(t, n) { return t.__proto__ = n, t })(e, t) } function h(e) { var t = function e() { if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (t) { return !1 } }(); return function n() { var i, r = s(e); if (t) { var o = s(this).constructor; i = Reflect.construct(r, arguments, o) } else i = r.apply(this, arguments); return function e(t, n) { if (n && ("object" == typeof n || "function" == typeof n)) return n; if (void 0 !== n) throw TypeError("Derived constructors may only return object or undefined"); return function e(t) { if (void 0 === t) throw ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(t) }(this, i) } } function f(e) { return function e(t) { if (Array.isArray(t)) return l(t) }(e) || function e(t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }(e) || function e(t, n) { if (t) { if ("string" == typeof t) return l(t, n); var i = Object.prototype.toString.call(t).slice(8, -1); if ("Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i) return Array.from(t); if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return l(t, n) } }(e) || function e() { throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function l(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, i = Array(t); n < t; n++)i[n] = e[n]; return i } function d(e) { var t = function e(t, n) { if ("object" != typeof t || null === t) return t; var i = t[Symbol.toPrimitive]; if (void 0 !== i) { var r = i.call(t, n || "default"); if ("object" != typeof r) return r; throw TypeError("@@toPrimitive must return a primitive value.") } return ("string" === n ? String : Number)(t) }(e, "string"); return "symbol" == typeof t ? t : String(t) } function v(e) { return Array.isArray ? Array.isArray(e) : "[object Array]" === k(e) } var g = 1 / 0; function p(e) { return "string" == typeof e } function y(e) { return "number" == typeof e } function $(e) { return "object" === n(e) } function _(e) { return null != e } function m(e) { return !e.trim().length } function k(e) { return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e) } var M = Object.prototype.hasOwnProperty, x = function () { function e(t) { var n = this; i(this, e), this._keys = [], this._keyMap = {}; var r = 0; t.forEach(function (e) { var t = b(e); n._keys.push(t), n._keyMap[t.id] = t, r += t.weight }), this._keys.forEach(function (e) { e.weight /= r }) } return o(e, [{ key: "get", value: function e(t) { return this._keyMap[t] } }, { key: "keys", value: function e() { return this._keys } }, { key: "toJSON", value: function e() { return JSON.stringify(this._keys) } }]), e }(); function b(e) { var t, n = null, i = null, r = null, o = 1, c = null; if (p(e) || v(e)) r = e, n = L(e), i = w(e); else { if (!M.call(e, "name")) { throw Error("Missing ".concat("name", " property in key")) } var a = e.name; if (r = a, M.call(e, "weight") && (o = e.weight) <= 0) throw Error((t = a, "Property 'weight' in key '".concat(t, "' must be a positive integer"))); n = L(a), i = w(a), c = e.getFn } return { path: n, id: i, weight: o, src: r, getFn: c } } function L(e) { return v(e) ? e : e.split(".") } function w(e) { return v(e) ? e.join(".") : e } var S = t(t(t(t({}, { isCaseSensitive: !1, includeScore: !1, keys: [], shouldSort: !0, sortFn: function e(t, n) { return t.score === n.score ? t.idx < n.idx ? -1 : 1 : t.score < n.score ? -1 : 1 } }), { includeMatches: !1, findAllMatches: !1, minMatchCharLength: 1 }), { location: 0, threshold: .6, distance: 100 }), { useExtendedSearch: !1, getFn: function e(t, n) { var i = [], r = !1; return !function e(t, n, o) { if (_(t)) { if (n[o]) { var c, a, s, u = t[n[o]]; if (_(u)) if (o === n.length - 1 && (p(u) || y(u) || !0 === (a = u) || !1 === a || (c = a, $(c) && null !== c && "[object Boolean]" == k(a)))) i.push(null == (s = u) ? "" : function e(t) { if ("string" == typeof t) return t; var n = t + ""; return "0" == n && 1 / t == -g ? "-0" : n }(s)); else if (v(u)) { r = !0; for (var h = 0, f = u.length; h < f; h += 1)e(u[h], n, o + 1) } else n.length && e(u, n, o + 1) } else i.push(t) } }(t, p(n) ? n.split(".") : n, 0), r ? i : i[0] }, ignoreLocation: !1, ignoreFieldNorm: !1, fieldNormWeight: 1 }), A = /[^ ]+/g, I = function () { function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = t.getFn, r = void 0 === n ? S.getFn : n, o = t.fieldNormWeight, c = void 0 === o ? S.fieldNormWeight : o; i(this, e), this.norm = function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3, i = new Map, r = Math.pow(10, n); return { get: function e(n) { var o = n.match(A).length; if (i.has(o)) return i.get(o); var c = parseFloat(Math.round(1 / Math.pow(o, .5 * t) * r) / r); return i.set(o, c), c }, clear: function e() { i.clear() } } }(c, 3), this.getFn = r, this.isCreated = !1, this.setIndexRecords() } return o(e, [{ key: "setSources", value: function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; this.docs = t } }, { key: "setIndexRecords", value: function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; this.records = t } }, { key: "setKeys", value: function e() { var t = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; this.keys = n, this._keysMap = {}, n.forEach(function (e, n) { t._keysMap[e.id] = n }) } }, { key: "create", value: function e() { var t = this; !this.isCreated && this.docs.length && (this.isCreated = !0, p(this.docs[0]) ? this.docs.forEach(function (e, n) { t._addString(e, n) }) : this.docs.forEach(function (e, n) { t._addObject(e, n) }), this.norm.clear()) } }, { key: "add", value: function e(t) { var n = this.size(); p(t) ? this._addString(t, n) : this._addObject(t, n) } }, { key: "removeAt", value: function e(t) { this.records.splice(t, 1); for (var n = t, i = this.size(); n < i; n += 1)this.records[n].i -= 1 } }, { key: "getValueForItemAtKeyId", value: function e(t, n) { return t[this._keysMap[n]] } }, { key: "size", value: function e() { return this.records.length } }, { key: "_addString", value: function e(t, n) { if (!(!_(t) || m(t))) { var i = { v: t, i: n, n: this.norm.get(t) }; this.records.push(i) } } }, { key: "_addObject", value: function e(t, n) { var i = this, r = { i: n, $: {} }; this.keys.forEach(function (e, n) { var o = e.getFn ? e.getFn(t) : i.getFn(t, e.path); if (_(o)) { if (v(o)) { for (var c = [], a = [{ nestedArrIndex: -1, value: o }]; a.length;) { var s = a.pop(), u = s.nestedArrIndex, h = s.value; if (_(h)) { if (p(h) && !m(h)) { var f = { v: h, i: u, n: i.norm.get(h) }; c.push(f) } else v(h) && h.forEach(function (e, t) { a.push({ nestedArrIndex: t, value: e }) }) } } r.$[n] = c } else if (p(o) && !m(o)) { var l = { v: o, n: i.norm.get(o) }; r.$[n] = l } } }), this.records.push(r) } }, { key: "toJSON", value: function e() { return { keys: this.keys, records: this.records } } }]), e }(); function C(e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = n.getFn, r = void 0 === i ? S.getFn : i, o = n.fieldNormWeight, c = void 0 === o ? S.fieldNormWeight : o, a = new I({ getFn: r, fieldNormWeight: c }); return a.setKeys(e.map(b)), a.setSources(t), a.create(), a } function E(e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = t.errors, i = t.currentLocation, r = t.expectedLocation, o = t.distance, c = void 0 === o ? S.distance : o, a = t.ignoreLocation, s = void 0 === a ? S.ignoreLocation : a, u = (void 0 === n ? 0 : n) / e.length; if (s) return u; var h = Math.abs((void 0 === r ? 0 : r) - (void 0 === i ? 0 : i)); return c ? u + h / c : h ? 1 : u } var P = function () { function e(t) { var n = this, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, o = r.location, c = void 0 === o ? S.location : o, a = r.threshold, s = void 0 === a ? S.threshold : a, u = r.distance, h = void 0 === u ? S.distance : u, f = r.includeMatches, l = void 0 === f ? S.includeMatches : f, d = r.findAllMatches, v = void 0 === d ? S.findAllMatches : d, g = r.minMatchCharLength, p = void 0 === g ? S.minMatchCharLength : g, y = r.isCaseSensitive, $ = void 0 === y ? S.isCaseSensitive : y, _ = r.ignoreLocation, m = void 0 === _ ? S.ignoreLocation : _; if (i(this, e), this.options = { location: c, threshold: s, distance: h, includeMatches: l, findAllMatches: v, minMatchCharLength: p, isCaseSensitive: $, ignoreLocation: m }, this.pattern = $ ? t : t.toLowerCase(), this.chunks = [], this.pattern.length) { var k = function e(t, i) { n.chunks.push({ pattern: t, alphabet: function e(t) { for (var n = {}, i = 0, r = t.length; i < r; i += 1) { var o = t.charAt(i); n[o] = (n[o] || 0) | 1 << r - i - 1 } return n }(t), startIndex: i }) }, M = this.pattern.length; if (M > 32) { for (var x = 0, b = M % 32, L = M - b; x < L;)k(this.pattern.substr(x, 32), x), x += 32; if (b) { var w = M - 32; k(this.pattern.substr(w), w) } } else k(this.pattern, 0) } } return o(e, [{ key: "searchIn", value: function e(t) { var n = this.options, i = n.isCaseSensitive, r = n.includeMatches; if (i || (t = t.toLowerCase()), this.pattern === t) { var o = { isMatch: !0, score: 0 }; return r && (o.indices = [[0, t.length - 1]]), o } var c = this.options, a = c.location, s = c.distance, u = c.threshold, h = c.findAllMatches, l = c.minMatchCharLength, d = c.ignoreLocation, v = [], g = 0, p = !1; this.chunks.forEach(function (e) { var n, i = e.pattern, o = function e(t, n, i) { var r, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, c = o.location, a = void 0 === c ? S.location : c, s = o.distance, u = void 0 === s ? S.distance : s, h = o.threshold, f = void 0 === h ? S.threshold : h, l = o.findAllMatches, d = void 0 === l ? S.findAllMatches : l, v = o.minMatchCharLength, g = void 0 === v ? S.minMatchCharLength : v, p = o.includeMatches, y = void 0 === p ? S.includeMatches : p, $ = o.ignoreLocation, _ = void 0 === $ ? S.ignoreLocation : $; if (n.length > 32) throw Error("Pattern length exceeds max of ".concat(32, ".")); for (var m = n.length, k = t.length, M = Math.max(0, Math.min(a, k)), x = f, b = M, L = g > 1 || y, w = L ? Array(k) : []; (r = t.indexOf(n, b)) > -1;)if (x = Math.min(E(n, { currentLocation: r, expectedLocation: M, distance: u, ignoreLocation: _ }), x), b = r + m, L) for (var A = 0; A < m;)w[r + A] = 1, A += 1; b = -1; for (var I = [], C = 1, P = m + k, F = 1 << m - 1, O = 0; O < m; O += 1) { for (var N = 0, R = P; N < R;)E(n, { errors: O, currentLocation: M + R, expectedLocation: M, distance: u, ignoreLocation: _ }) <= x ? N = R : P = R, R = Math.floor((P - N) / 2 + N); P = R; var j = Math.max(1, M - R + 1), W = d ? k : Math.min(M + R, k) + m, D = Array(W + 2); D[W + 1] = (1 << O) - 1; for (var T = W; T >= j; T -= 1) { var z = T - 1, K = i[t.charAt(z)]; if (L && (w[z] = +!!K), D[T] = (D[T + 1] << 1 | 1) & K, O && (D[T] |= (I[T + 1] | I[T]) << 1 | 1 | I[T + 1]), D[T] & F && (C = E(n, { errors: O, currentLocation: z, expectedLocation: M, distance: u, ignoreLocation: _ })) <= x) { if (x = C, (b = z) <= M) break; j = Math.max(1, 2 * M - b) } } if (E(n, { errors: O + 1, currentLocation: M, expectedLocation: M, distance: u, ignoreLocation: _ }) > x) break; I = D } var q = { isMatch: b >= 0, score: Math.max(.001, C) }; if (L) { var H = function e() { for (var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : S.minMatchCharLength, i = [], r = -1, o = -1, c = 0, a = t.length; c < a; c += 1) { var s = t[c]; s && -1 === r ? r = c : s || -1 === r || ((o = c - 1) - r + 1 >= n && i.push([r, o]), r = -1) } return t[c - 1] && c - r >= n && i.push([r, c - 1]), i }(w, g); H.length ? y && (q.indices = H) : q.isMatch = !1 } return q }(t, i, e.alphabet, { location: a + e.startIndex, distance: s, threshold: u, findAllMatches: h, minMatchCharLength: l, includeMatches: r, ignoreLocation: d }), c = o.isMatch, y = o.score, $ = o.indices; c && (p = !0), g += y, c && $ && (v = [].concat(f(v), f($))) }); var y = { isMatch: p, score: p ? g / this.chunks.length : 1 }; return p && r && (y.indices = v), y } }]), e }(), F = function () { function e(t) { i(this, e), this.pattern = t } return o(e, [{ key: "search", value: function e() { } }], [{ key: "isMultiMatch", value: function e(t) { return O(t, this.multiRegex) } }, { key: "isSingleMatch", value: function e(t) { return O(t, this.singleRegex) } }]), e }(); function O(e, t) { var n = e.match(t); return n ? n[1] : null } var N = function (e) { a(n, e); var t = h(n); function n(e) { return i(this, n), t.call(this, e) } return o(n, [{ key: "search", value: function e(t) { var n = t === this.pattern; return { isMatch: n, score: n ? 0 : 1, indices: [0, this.pattern.length - 1] } } }], [{ key: "type", get: function e() { return "exact" } }, { key: "multiRegex", get: function e() { return /^="(.*)"$/ } }, { key: "singleRegex", get: function e() { return /^=(.*)$/ } }]), n }(F), R = function (e) { a(n, e); var t = h(n); function n(e) { return i(this, n), t.call(this, e) } return o(n, [{ key: "search", value: function e(t) { var n = -1 === t.indexOf(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [0, t.length - 1] } } }], [{ key: "type", get: function e() { return "inverse-exact" } }, { key: "multiRegex", get: function e() { return /^!"(.*)"$/ } }, { key: "singleRegex", get: function e() { return /^!(.*)$/ } }]), n }(F), j = function (e) { a(n, e); var t = h(n); function n(e) { return i(this, n), t.call(this, e) } return o(n, [{ key: "search", value: function e(t) { var n = t.startsWith(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [0, this.pattern.length - 1] } } }], [{ key: "type", get: function e() { return "prefix-exact" } }, { key: "multiRegex", get: function e() { return /^\^"(.*)"$/ } }, { key: "singleRegex", get: function e() { return /^\^(.*)$/ } }]), n }(F), W = function (e) { a(n, e); var t = h(n); function n(e) { return i(this, n), t.call(this, e) } return o(n, [{ key: "search", value: function e(t) { var n = !t.startsWith(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [0, t.length - 1] } } }], [{ key: "type", get: function e() { return "inverse-prefix-exact" } }, { key: "multiRegex", get: function e() { return /^!\^"(.*)"$/ } }, { key: "singleRegex", get: function e() { return /^!\^(.*)$/ } }]), n }(F), D = function (e) { a(n, e); var t = h(n); function n(e) { return i(this, n), t.call(this, e) } return o(n, [{ key: "search", value: function e(t) { var n = t.endsWith(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [t.length - this.pattern.length, t.length - 1] } } }], [{ key: "type", get: function e() { return "suffix-exact" } }, { key: "multiRegex", get: function e() { return /^"(.*)"\$$/ } }, { key: "singleRegex", get: function e() { return /^(.*)\$$/ } }]), n }(F), T = function (e) { a(n, e); var t = h(n); function n(e) { return i(this, n), t.call(this, e) } return o(n, [{ key: "search", value: function e(t) { var n = !t.endsWith(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [0, t.length - 1] } } }], [{ key: "type", get: function e() { return "inverse-suffix-exact" } }, { key: "multiRegex", get: function e() { return /^!"(.*)"\$$/ } }, { key: "singleRegex", get: function e() { return /^!(.*)\$$/ } }]), n }(F), z = function (e) { a(n, e); var t = h(n); function n(e) { var r, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, c = o.location, a = void 0 === c ? S.location : c, s = o.threshold, u = void 0 === s ? S.threshold : s, h = o.distance, f = void 0 === h ? S.distance : h, l = o.includeMatches, d = void 0 === l ? S.includeMatches : l, v = o.findAllMatches, g = void 0 === v ? S.findAllMatches : v, p = o.minMatchCharLength, y = void 0 === p ? S.minMatchCharLength : p, $ = o.isCaseSensitive, _ = void 0 === $ ? S.isCaseSensitive : $, m = o.ignoreLocation, k = void 0 === m ? S.ignoreLocation : m; return i(this, n), (r = t.call(this, e))._bitapSearch = new P(e, { location: a, threshold: u, distance: f, includeMatches: d, findAllMatches: g, minMatchCharLength: y, isCaseSensitive: _, ignoreLocation: k }), r } return o(n, [{ key: "search", value: function e(t) { return this._bitapSearch.searchIn(t) } }], [{ key: "type", get: function e() { return "fuzzy" } }, { key: "multiRegex", get: function e() { return /^"(.*)"$/ } }, { key: "singleRegex", get: function e() { return /^(.*)$/ } }]), n }(F), K = function (e) { a(n, e); var t = h(n); function n(e) { return i(this, n), t.call(this, e) } return o(n, [{ key: "search", value: function e(t) { for (var n, i = 0, r = [], o = this.pattern.length; (n = t.indexOf(this.pattern, i)) > -1;)i = n + o, r.push([n, i - 1]); var c = !!r.length; return { isMatch: c, score: c ? 0 : 1, indices: r } } }], [{ key: "type", get: function e() { return "include" } }, { key: "multiRegex", get: function e() { return /^'"(.*)"$/ } }, { key: "singleRegex", get: function e() { return /^'(.*)$/ } }]), n }(F), q = [N, K, j, W, T, D, R, z], H = q.length, J = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, U = new Set([z.type, K.type]), V = function () { function e(t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = n.isCaseSensitive, o = void 0 === r ? S.isCaseSensitive : r, c = n.includeMatches, a = void 0 === c ? S.includeMatches : c, s = n.minMatchCharLength, u = void 0 === s ? S.minMatchCharLength : s, h = n.ignoreLocation, f = void 0 === h ? S.ignoreLocation : h, l = n.findAllMatches, d = void 0 === l ? S.findAllMatches : l, v = n.location, g = void 0 === v ? S.location : v, p = n.threshold, y = void 0 === p ? S.threshold : p, $ = n.distance, _ = void 0 === $ ? S.distance : $; i(this, e), this.query = null, this.options = { isCaseSensitive: o, includeMatches: a, minMatchCharLength: u, findAllMatches: d, ignoreLocation: f, location: g, threshold: y, distance: _ }, this.pattern = o ? t : t.toLowerCase(), this.query = function e(t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return t.split("|").map(function (e) { for (var t = e.trim().split(J).filter(function (e) { return e && !!e.trim() }), i = [], r = 0, o = t.length; r < o; r += 1) { for (var c = t[r], a = !1, s = -1; !a && ++s < H;) { var u = q[s], h = u.isMultiMatch(c); h && (i.push(new u(h, n)), a = !0) } if (!a) for (s = -1; ++s < H;) { var f = q[s], l = f.isSingleMatch(c); if (l) { i.push(new f(l, n)); break } } } return i }) }(this.pattern, this.options) } return o(e, [{ key: "searchIn", value: function e(t) { var n = this.query; if (!n) return { isMatch: !1, score: 1 }; var i = this.options, r = i.includeMatches; t = i.isCaseSensitive ? t : t.toLowerCase(); for (var o = 0, c = [], a = 0, s = 0, u = n.length; s < u; s += 1) { var h = n[s]; c.length = 0, o = 0; for (var l = 0, d = h.length; l < d; l += 1) { var v = h[l], g = v.search(t), p = g.isMatch, y = g.indices, $ = g.score; if (p) { if (o += 1, a += $, r) { var _ = v.constructor.type; U.has(_) ? c = [].concat(f(c), f(y)) : c.push(y) } } else { a = 0, o = 0, c.length = 0; break } } if (o) { var m = { isMatch: !0, score: a / o }; return r && (m.indices = c), m } } return { isMatch: !1, score: 1 } } }], [{ key: "condition", value: function e(t, n) { return n.useExtendedSearch } }]), e }(), B = []; function Q(e, t) { for (var n = 0, i = B.length; n < i; n += 1) { var r = B[n]; if (r.condition(e, t)) return new r(e, t) } return new P(e, t) } var G = { AND: "$and", OR: "$or" }, X = { PATH: "$path", PATTERN: "$val" }, Y = function e(t) { return !!(t[G.AND] || t[G.OR]) }, Z = function e(t) { return c({}, G.AND, Object.keys(t).map(function (e) { return c({}, e, t[e]) })) }; function ee(e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = n.auto, r = void 0 === i || i; return Y(e) || (e = Z(e)), function e(n) { var i, o = Object.keys(n), c = !!(i = n)[X.PATH]; if (!c && o.length > 1 && !Y(n)) return e(Z(n)); if (!v(a = n) && $(a) && !Y(a)) { var a, s, u = c ? n[X.PATH] : o[0], h = c ? n[X.PATTERN] : n[u]; if (!p(h)) throw Error((s = u, "Invalid value for key ".concat(s))); var f = { keyId: w(u), pattern: h }; return r && (f.searcher = Q(h, t)), f } var l = { children: [], operator: o[0] }; return o.forEach(function (t) { var i = n[t]; v(i) && i.forEach(function (t) { l.children.push(e(t)) }) }), l }(e) } function et(e, t) { var n = e.matches; t.matches = [], _(n) && n.forEach(function (e) { if (_(e.indices) && e.indices.length) { var n, i = { indices: e.indices, value: e.value }; e.key && (i.key = e.key.src), e.idx > -1 && (i.refIndex = e.idx), t.matches.push(i) } }) } function en(e, t) { t.score = e.score } var ei = function () { function e(n) { var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, o = arguments.length > 2 ? arguments[2] : void 0; i(this, e), this.options = t(t({}, S), r), this.options.useExtendedSearch, this._keyStore = new x(this.options.keys), this.setCollection(n, o) } return o(e, [{ key: "setCollection", value: function e(t, n) { if (this._docs = t, n && !(n instanceof I)) throw Error("Incorrect 'index' type"); this._myIndex = n || C(this.options.keys, this._docs, { getFn: this.options.getFn, fieldNormWeight: this.options.fieldNormWeight }) } }, { key: "add", value: function e(t) { _(t) && (this._docs.push(t), this._myIndex.add(t)) } }, { key: "remove", value: function e() { for (var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () { return !1 }, n = [], i = 0, r = this._docs.length; i < r; i += 1) { var o = this._docs[i]; t(o, i) && (this.removeAt(i), i -= 1, r -= 1, n.push(o)) } return n } }, { key: "removeAt", value: function e(t) { this._docs.splice(t, 1), this._myIndex.removeAt(t) } }, { key: "getIndex", value: function e() { return this._myIndex } }, { key: "search", value: function e(t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = n.limit, r = void 0 === i ? -1 : i, o = this.options, c = o.includeMatches, a = o.includeScore, s = o.shouldSort, u = o.sortFn, h = o.ignoreFieldNorm, f = p(t) ? p(this._docs[0]) ? this._searchStringList(t) : this._searchObjectList(t) : this._searchLogical(t); return function e(t, n) { var i = n.ignoreFieldNorm, r = void 0 === i ? S.ignoreFieldNorm : i; t.forEach(function (e) { var t = 1; e.matches.forEach(function (e) { var n = e.key, i = e.norm, o = e.score, c = n ? n.weight : null; t *= Math.pow(0 === o && c ? Number.EPSILON : o, (c || 1) * (r ? 1 : i)) }), e.score = t }) }(f, { ignoreFieldNorm: h }), s && f.sort(u), y(r) && r > -1 && (f = f.slice(0, r)), function e(t, n) { var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = i.includeMatches, o = void 0 === r ? S.includeMatches : r, c = i.includeScore, a = void 0 === c ? S.includeScore : c, s = []; return o && s.push(et), a && s.push(en), t.map(function (e) { var t = e.idx, i = { item: n[t], refIndex: t }; return s.length && s.forEach(function (t) { t(e, i) }), i }) }(f, this._docs, { includeMatches: c, includeScore: a }) } }, { key: "_searchStringList", value: function e(t) { var n = Q(t, this.options), i = this._myIndex.records, r = []; return i.forEach(function (e) { var t = e.v, i = e.i, o = e.n; if (_(t)) { var c = n.searchIn(t), a = c.isMatch, s = c.score, u = c.indices; a && r.push({ item: t, idx: i, matches: [{ score: s, value: t, norm: o, indices: u }] }) } }), r } }, { key: "_searchLogical", value: function e(t) { var n = this, i = ee(t, this.options), r = function e(t, i, r) { if (!t.children) { var o = t.keyId, c = t.searcher, a = n._findMatches({ key: n._keyStore.get(o), value: n._myIndex.getValueForItemAtKeyId(i, o), searcher: c }); return a && a.length ? [{ idx: r, item: i, matches: a }] : [] } for (var s = [], u = 0, h = t.children.length; u < h; u += 1) { var l = e(t.children[u], i, r); if (l.length) s.push.apply(s, f(l)); else if (t.operator === G.AND) return [] } return s }, o = this._myIndex.records, c = {}, a = []; return o.forEach(function (e) { var t = e.$, n = e.i; if (_(t)) { var o = r(i, t, n); o.length && (c[n] || (c[n] = { idx: n, item: t, matches: [] }, a.push(c[n])), o.forEach(function (e) { var t, i = e.matches; (t = c[n].matches).push.apply(t, f(i)) })) } }), a } }, { key: "_searchObjectList", value: function e(t) { var n = this, i = Q(t, this.options), r = this._myIndex, o = r.keys, c = r.records, a = []; return c.forEach(function (e) { var t = e.$, r = e.i; if (_(t)) { var c = []; o.forEach(function (e, r) { c.push.apply(c, f(n._findMatches({ key: e, value: t[r], searcher: i }))) }), c.length && a.push({ idx: r, item: t, matches: c }) } }), a } }, { key: "_findMatches", value: function e(t) { var n = t.key, i = t.value, r = t.searcher; if (!_(i)) return []; var o = []; if (v(i)) i.forEach(function (e) { var t = e.v, i = e.i, c = e.n; if (_(t)) { var a = r.searchIn(t), s = a.isMatch, u = a.score, h = a.indices; s && o.push({ score: u, key: n, value: t, idx: i, norm: c, indices: h }) } }); else { var c = i.v, a = i.n, s = r.searchIn(c), u = s.isMatch, h = s.score, f = s.indices; u && o.push({ score: h, key: n, value: c, norm: a, indices: f }) } return o } }]), e }(); return ei.version = "7.0.0", ei.createIndex = C, ei.parseIndex = function e(t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = n.getFn, r = void 0 === i ? S.getFn : i, o = n.fieldNormWeight, c = void 0 === o ? S.fieldNormWeight : o, a = t.keys, s = t.records, u = new I({ getFn: r, fieldNormWeight: c }); return u.setKeys(a), u.setIndexRecords(s), u }, ei.config = S, ei.parseQuery = ee, !function e() { B.push.apply(B, arguments) }(V), ei });